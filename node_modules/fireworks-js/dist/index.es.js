/**
 * name: fireworks-js
 * version: 2.0.0
 * author: Vitalij Ryndin (https://crashmax.ru)
 * homepage: https://fireworks.js.org
 * license MIT
 */
function l(e, t) {
  return Math.random() * (t - e) + e;
}
function a(e, t) {
  return Math.floor(l(e, t + 1));
}
function f(e, t, i, s) {
  const h = Math.pow;
  return Math.sqrt(h(e - i, 2) + h(t - s, 2));
}
function x(e, t, i = 1) {
  if (e > 360 || e < 0)
    throw new Error(`Expected hue 0-360 range, got \`${e}\``);
  if (t > 100 || t < 0)
    throw new Error(`Expected lightness 0-100 range, got \`${t}\``);
  if (i > 1 || i < 0)
    throw new Error(`Expected alpha 0-1 range, got \`${i}\``);
  return `hsla(${e}, 100%, ${t}%, ${i})`;
}
const g = (e) => {
  if (typeof e == "object" && e !== null) {
    if (typeof Object.getPrototypeOf == "function") {
      const t = Object.getPrototypeOf(e);
      return t === Object.prototype || t === null;
    }
    return Object.prototype.toString.call(e) === "[object Object]";
  }
  return !1;
}, b = [
  "__proto__",
  "constructor",
  "prototype"
], v = (...e) => e.reduce((t, i) => (Object.keys(i).forEach((s) => {
  b.includes(s) || (Array.isArray(t[s]) && Array.isArray(i[s]) ? t[s] = i[s] : g(t[s]) && g(i[s]) ? t[s] = v(t[s], i[s]) : t[s] = i[s]);
}), t), {});
class y {
  constructor({
    x: t,
    y: i,
    ctx: s,
    hue: h,
    decay: r,
    gravity: c,
    friction: u,
    brightness: o,
    flickering: d,
    lineWidth: p,
    explosionLength: m
  }) {
    for (this.coordinates = [], this.alpha = 1, this.x = t, this.y = i, this.ctx = s, this.hue = h, this.gravity = c, this.friction = u, this.flickering = d, this.lineWidth = p, this.explosionLength = m, this.angle = l(0, Math.PI * 2), this.speed = a(1, 10), this.brightness = a(o.min, o.max), this.decay = l(r.min, r.max); this.explosionLength--; )
      this.coordinates.push([t, i]);
  }
  update(t) {
    this.coordinates.pop(), this.coordinates.unshift([this.x, this.y]), this.speed *= this.friction, this.x += Math.cos(this.angle) * this.speed, this.y += Math.sin(this.angle) * this.speed + this.gravity, this.alpha -= this.decay, this.alpha <= this.decay && t();
  }
  draw() {
    const t = this.coordinates.length - 1;
    this.ctx.beginPath(), this.ctx.lineWidth = this.lineWidth, this.ctx.fillStyle = x(this.hue, this.brightness, this.alpha), this.ctx.moveTo(this.coordinates[t][0], this.coordinates[t][1]), this.ctx.lineTo(this.x, this.y), this.ctx.strokeStyle = x(this.hue, this.flickering ? l(0, this.brightness) : this.brightness, this.alpha), this.ctx.stroke();
  }
}
class E {
  constructor() {
    this.autoresize = !0, this.lineStyle = "round", this.flickering = 50, this.trace = 3, this.traceSpeed = 10, this.intensity = 30, this.explosion = 5, this.gravity = 1.5, this.opacity = 0.5, this.particles = 50, this.friction = 0.95, this.acceleration = 1.05, this.hue = {
      min: 0,
      max: 360
    }, this.rocketsPoint = {
      min: 50,
      max: 50
    }, this.lineWidth = {
      explosion: {
        min: 1,
        max: 3
      },
      trace: {
        min: 1,
        max: 2
      }
    }, this.mouse = {
      click: !1,
      move: !1,
      max: 1
    }, this.delay = {
      min: 15,
      max: 30
    }, this.brightness = {
      min: 50,
      max: 80
    }, this.decay = {
      min: 0.015,
      max: 0.03
    }, this.sound = {
      enabled: !1,
      files: [
        "explosion0.mp3",
        "explosion1.mp3",
        "explosion2.mp3"
      ],
      volume: {
        min: 4,
        max: 8
      }
    }, this.boundaries = {
      height: 0,
      width: 0,
      x: 50,
      y: 50
    };
  }
  updateOptions(t) {
    Object.assign(this, v(this, t));
  }
}
const n = new E();
class M {
  constructor(t) {
    this.canvas = t, this.active = !1;
  }
  subscribe() {
    this.canvas.addEventListener("mousedown", (t) => this.mouseDown(t)), this.canvas.addEventListener("mouseup", (t) => this.mouseUp(t)), this.canvas.addEventListener("mousemove", (t) => this.mouseMove(t));
  }
  unsubscribe() {
    this.canvas.removeEventListener("mousedown", this.mouseDown), this.canvas.removeEventListener("mouseup", this.mouseUp), this.canvas.removeEventListener("mousemove", this.mouseMove);
  }
  useMouse(t, i) {
    (n.mouse.click || n.mouse.move) && (this.x = t.pageX - this.canvas.offsetLeft, this.y = t.pageY - this.canvas.offsetTop, this.active = i);
  }
  mouseDown(t) {
    this.useMouse(t, n.mouse.click);
  }
  mouseUp(t) {
    this.useMouse(t, !1);
  }
  mouseMove(t) {
    this.useMouse(t, this.active);
  }
}
class L {
  constructor(t) {
    this.fireworks = t;
  }
  subscribe() {
    n.autoresize && window.addEventListener("resize", () => this.bindResize());
  }
  unsubscribe() {
    n.autoresize && window.removeEventListener("resize", this.bindResize);
  }
  bindResize() {
    this.fireworks.updateSize();
  }
}
class O {
  constructor() {
    this.sounds = [], this.onInit = !1, this.init();
  }
  init() {
    !this.onInit && n.sound.enabled && (this.onInit = !0, this.audioContext = new (window.AudioContext || window.webkitAudioContext)(), this.loadSounds());
  }
  async loadSounds() {
    for (const t of n.sound.files) {
      const i = await (await fetch(t)).arrayBuffer();
      this.audioContext.decodeAudioData(i).then((s) => {
        this.sounds.push(s);
      }).catch((s) => {
        throw s;
      });
    }
  }
  play() {
    if (n.sound.enabled && this.sounds.length) {
      const t = this.audioContext.createBufferSource(), i = this.sounds[a(0, this.sounds.length - 1)], s = this.audioContext.createGain();
      t.buffer = i, s.gain.value = l(n.sound.volume.min / 100, n.sound.volume.max / 100), s.connect(this.audioContext.destination), t.connect(s), t.start(0);
    } else
      this.init();
  }
}
class S {
  constructor({
    x: t,
    y: i,
    dx: s,
    dy: h,
    ctx: r,
    hue: c,
    speed: u,
    traceLength: o,
    acceleration: d
  }) {
    for (this.coordinates = [], this.currentDistance = 0, this.x = t, this.y = i, this.sx = t, this.sy = i, this.dx = s, this.dy = h, this.ctx = r, this.hue = c, this.speed = u, this.traceLength = o, this.acceleration = d, this.totalDistance = f(t, i, s, h), this.angle = Math.atan2(h - i, s - t), this.brightness = a(50, 70); this.traceLength--; )
      this.coordinates.push([t, i]);
  }
  update(t) {
    this.coordinates.pop(), this.coordinates.unshift([this.x, this.y]), this.speed *= this.acceleration;
    const i = Math.cos(this.angle) * this.speed, s = Math.sin(this.angle) * this.speed;
    this.currentDistance = f(this.sx, this.sy, this.x + i, this.y + s), this.currentDistance >= this.totalDistance ? t(this.dx, this.dy, this.hue) : (this.x += i, this.y += s);
  }
  draw() {
    const t = this.coordinates.length - 1;
    this.ctx.beginPath(), this.ctx.moveTo(this.coordinates[t][0], this.coordinates[t][1]), this.ctx.lineTo(this.x, this.y), this.ctx.strokeStyle = x(this.hue, this.brightness), this.ctx.stroke();
  }
}
class C {
  constructor(t, i = {}) {
    this.tick = 0, this.timestamp = performance.now(), this.running = !1, this.traces = [], this.explosions = [], this.container = t, t instanceof HTMLCanvasElement ? this.canvas = t : (this.canvas = document.createElement("canvas"), this.container.appendChild(this.canvas)), this.ctx = this.canvas.getContext("2d"), this.updateOptions(i), this.updateSize(), this.sound = new O(), this.resize = new L(this), this.mouse = new M(this.canvas);
  }
  get isRunning() {
    return this.running;
  }
  get "2.0.0"() {
    return "2.0.0";
  }
  start() {
    this.running || (this.running = !0, this.resize.subscribe(), this.mouse.subscribe(), this.clear(), this.render());
  }
  stop() {
    !this.running || (this.running = !1, this.resize.unsubscribe(), this.mouse.unsubscribe(), this.clear());
  }
  pause() {
    this.running = !this.running, this.running && this.render();
  }
  clear() {
    !this.ctx || (this.traces = [], this.explosions = [], this.ctx.clearRect(0, 0, this.width, this.height));
  }
  updateOptions(t) {
    n.updateOptions(t);
  }
  updateSize({
    width: t = this.container instanceof HTMLCanvasElement ? this.canvas.width : this.container.clientWidth,
    height: i = this.container instanceof HTMLCanvasElement ? this.canvas.height : this.container.clientHeight
  } = {}) {
    this.width = t, this.height = i, this.canvas.width = t, this.canvas.height = i, this.updateBoundaries({
      ...n.boundaries,
      width: t,
      height: i
    });
  }
  updateBoundaries(t) {
    this.updateOptions({ boundaries: t });
  }
  render(t = this.timestamp) {
    if (!this.ctx || !this.running)
      return;
    requestAnimationFrame((s) => this.render(s)), this.ctx.globalCompositeOperation = "destination-out", this.ctx.fillStyle = `rgba(0, 0, 0, ${n.opacity})`, this.ctx.fillRect(0, 0, this.width, this.height), this.ctx.globalCompositeOperation = "lighter", this.ctx.lineCap = n.lineStyle, this.ctx.lineJoin = "round", this.initTrace(), this.drawTrace(), this.drawExplosion();
    const i = t - this.timestamp;
    this.timestamp = t, this.tick += i * (n.intensity * Math.PI) / 1e3;
  }
  initTrace() {
    const {
      hue: t,
      delay: i,
      rocketsPoint: s,
      boundaries: h,
      trace: r,
      traceSpeed: c,
      acceleration: u,
      mouse: o
    } = n;
    (this.tick > a(i.min, i.max) || this.mouse.active && o.max > this.traces.length) && (this.traces.push(new S({
      x: this.width * a(s.min, s.max) / 100,
      y: this.height,
      dx: this.mouse.x && o.move || this.mouse.active ? this.mouse.x : a(h.x, h.width - h.x * 2),
      dy: this.mouse.y && o.move || this.mouse.active ? this.mouse.y : a(h.y, h.height * 0.5),
      ctx: this.ctx,
      hue: a(t.min, t.max),
      speed: c,
      acceleration: u,
      traceLength: r
    })), this.tick = 0);
  }
  drawTrace() {
    this.ctx.lineWidth = l(n.lineWidth.trace.min, n.lineWidth.trace.max);
    let t = this.traces.length;
    for (; t--; )
      this.traces[t].draw(), this.traces[t].update((i, s, h) => {
        this.initExplosion(i, s, h), this.sound.play(), this.traces.splice(t, 1);
      });
  }
  initExplosion(t, i, s) {
    const {
      particles: h,
      flickering: r,
      lineWidth: c,
      explosion: u,
      brightness: o,
      friction: d,
      gravity: p,
      decay: m
    } = n;
    let w = h;
    for (; w--; )
      this.explosions.push(new y({
        x: t,
        y: i,
        ctx: this.ctx,
        hue: s,
        friction: d,
        gravity: p,
        flickering: a(0, 100) <= r,
        lineWidth: l(c.explosion.min, c.explosion.max),
        explosionLength: Math.round(u),
        brightness: o,
        decay: m
      }));
  }
  drawExplosion() {
    let t = this.explosions.length;
    for (; t--; )
      this.explosions[t].draw(), this.explosions[t].update(() => {
        this.explosions.splice(t, 1);
      });
  }
}
export {
  C as Fireworks,
  C as default
};
